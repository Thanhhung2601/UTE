"use strict";
const WVPL_MAX_FAILED_ATTEMPTS = 5;
let microStart = 0;
class WVPLEngine {
    constructor(t) {
        this.setVars(t), this.setupObservers(), this.active = !0, this.instances = [], this.currentId, this.currentInstance = null, this.failedAttempts = 0, this.peakLength = 1920, this.setupAudioEngine(), this.node = document.querySelector("#wvpl-sticky-player"), this.start()
    }
    setupAudioEngine(t) {
        this.setAudioType(t), this.webAudio = new Audio, this.webAudio.preload = "metadata", this.webAudio.crossOrigin = "anonymous", this.mediaElement = new Audio, this.mediaElement.preload = "metadata", this.volume = 1, this.muted = !1, delete this.audioCtx, delete this.gain, delete this.analyserGain, this.isWebAudio() && (this.audioCtx = new(window.AudioContext || window.webkitAudioContext), this.gain = this.audioCtx.createGain(), this.analyserGain = this.audioCtx.createGain(), this.createSource(), this.setSmoothingTimeConstant(parseFloat(this.getOption("wave_animation") || 1))), this.addEvents()
    }
    setAudioType(t) {
        if (t = t || "WebAudio", this.audioType = t, navigator && navigator.appVersion) {
            if (navigator.appVersion.indexOf("OS 13_") >= 0 && this.getOption("force_ios_media_element")) return void(this.audioType = "MediaElement");
            if (navigator.appVersion.indexOf("OS 14_") >= 0 && this.getOption("force_ios_media_element")) return void(this.audioType = "MediaElement")
        }
        this.isSafari() && this.getOption("force_safari_media_element") && (this.audioType = "MediaElement")
    }
    isWebAudio() {
        return "WebAudio" === this.audioType
    }
    isMediaElement() {
        return "WebAudio" !== this.audioType
    }
    audio() {
        return this.isWebAudio() ? this.webAudio : this.mediaElement
    }
    requestAnimationFrame(t, e) {
        const s = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(t, e) {
            window.setTimeout(t, 1e3 / 30)
        };
        return s.call(window, e.bind(t))
    }
    cancelAnimationFrame() {
        const t = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
        t.call(window, this.afRequest)
    }
    setupObservers() {
        this.setupInstanceObserver(), this.setupVariationFormObserver()
    }
    setupInstanceObserver() {
        const t = {
            attributes: !1,
            childList: !0,
            subtree: !0
        };
        this.instanceObserver = new MutationObserver((t, e) => {
            t.forEach(t => {
                t.target.querySelector(".waveplayer:not(.active)") && this.loadInstances()
            })
        }), this.instanceObserver.observe(document.body, t)
    }
    setupVariationFormObserver() {
        if (!this.vars.wc_version) return;
        if (document.querySelector("#wvpl-variation-popup") || (this.variationPopup = document.createElement("div"), this.variationPopup.id = "wvpl-variation-popup", this.variationPopup.classList.add("woocommerce", "single-product"), document.body.appendChild(this.variationPopup)), this.variationPopup.innerHTML = "", !this.variationPopupOvserver) {
            const t = {
                attributes: !0,
                childList: !0,
                subtree: !0
            };
            this.variationPopupOvserver = new MutationObserver(this.variationFormCallback), this.variationPopupOvserver.observe(this.variationPopup, t)
        }
        const t = document.createElement("div");
        t.classList.add("product", "wvpl-variation-form"), jQuery(t).on("wc_variation_form", t => {
            document.body.classList.add("wvpl-variation-popup")
        }), this.variationPopup.append(t)
    }
    setVars(t) {
        this.vars = t.wvplVars, this.__ = t.wp.i18n.__, this._n = t.wp.i18n._n, this.template = t.lodash.template
    }
    isSafari() {
        return navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && -1 == navigator.userAgent.indexOf("CriOS") && -1 == navigator.userAgent.indexOf("FxiOS")
    }
    isDocumentHidden() {
        return void 0 !== document.hidden ? document.hidden : void 0 !== document.msHidden ? document.msHidden : void 0 !== document.webkitHidden && document.webkitHidden
    }
    getInstanceById(t) {
        return t = t || this.getCurrentId(), this.instances.find(e => e.id === t)
    }
    nextInstance() {
        const t = this.getVisibleInstancesInDOM();
        let e = this.getCurrentIndex();
        return e < 0 ? t[0] : (e++, !(e >= this.instances.length) && t[e])
    }
    prevInstance() {
        const t = this.getVisibleInstancesInDOM();
        let e = this.getCurrentIndex();
        return !(e < 0) && (e--, !(e < 0) && t[e])
    }
    addInstance(t, e, s) {
        const i = this.instances.find(e => e.id === t.dataset.instance_id);
        if (!i) {
            for (const t of e) t.peaks && !Array.isArray(t.peaks) && (t.peaks = this.readPeaks(t.peaks));
            const i = new WVPLInstance(t, e, s, this);
            this.instances.push(i)
        }
    }
    removeInstance(t) {
        const e = this.getInstanceById(t);
        if (e) {
            const e = this.getCurrentIndex(t);
            this.instances.splice(e, 1)
        }
    }
    getElement(t) {
        return t = t || this.getCurrentId(), document.getElementById(t)
    }
    getOption(t) {
        return this.vars.options[t]
    }
    setOption(t, e) {
        this.vars.options[t] = e, this.redrawAllInstances()
    }
    getInstancesInDOM() {
        if (this.instances) return this.instances.filter(t => document.querySelector(`.waveplayer[data-instance_id="${t.id}"]`))
    }
    getVisibleInstancesInDOM() {
        const t = this.getInstancesInDOM();
        return t.filter(t => t.node.offsetParent)
    }
    getFirstInstanceInDOM() {
        const t = this.getVisibleInstancesInDOM();
        return t ? t[0] : null
    }
    getCurrentId() {
        const t = this.getFirstInstanceInDOM();
        return this.currentId || t.id
    }
    isInstanceInDOM(t) {
        return t = t || this.currentId, this.getInstancesInDOM().find(e => e.id === t)
    }
    getCurrentInstance() {
        return void 0 === this.currentId ? this.getFirstInstanceInDOM() : this.instances.find(t => t.id === this.currentId)
    }
    setCurrentInstance(t, e) {
        if (t = t || this.getFirstInstanceInDOM(), t) {
            if (!this.currentId || e) {
                const e = this.getCurrentInstance();
                e && e.stop(), this.currentId = t.id
            }
            this.node && (this.node.dataset.instance_id = t.id), this.redrawAllInstances()
        }
    }
    start() {
        const t = new CustomEvent("waveplayer.engine.ready", {
            detail: {
                engine: this
            }
        });
        document.dispatchEvent(t), this.stickyPlayerInit(), this.navigatorInit(), this.loadInstances(), this.setCurrentInstance();
        let e = this.getVisibleInstancesInDOM().find(t => t.autoplay);
        Number(this.getOption("autoplay")) && (e = this.getFirstInstanceInDOM()), e && (e.node.classList.contains("wvpl-rendered") ? e.play() : e.playerInit(!0))
    }
    getCurrentIndex(t) {
        return t = t || this.currentId, this.getVisibleInstancesInDOM().findIndex(e => e.id === t)
    }
    getTrack(t) {
        return this.getCurrentInstance().getTrack(t)
    }
    getCurrentTrack() {
        return this.getTrack()
    }
    getCurrentTrackIndex() {
        return this.getCurrentInstance().getCurrentTrackIndex()
    }
    getColorStyleFromPalette(t) {
        const e = ["fc", "fc-s", "bc", "bc-s", "hc", "hc-s", "wc", "wc-s", "pc", "pc-s", "cc", "cc-s"];
        let s = {};
        for (const i in e) {
            const a = [parseInt(`0x${t[i].slice(0,2)}`), parseInt(`0x${t[i].slice(2,4)}`), parseInt(`0x${t[i].slice(4,6)}`)].join(", ");
            s[`--${e[i]}`] = a
        }
        return s
    }
    findTrack(t, e = "id") {
        const s = this.instances.map(t => t.tracks).flat().filter(s => String(s[e]) === String(t));
        return !!s.length && s[0]
    }
    skip(t = !0) {
        this.hasEnded ? this.hasEnded = !1 : this.trigger("skip");
        const e = this.getCurrentInstance(),
            s = this.prevInstance(),
            i = this.nextInstance(),
            a = this.isInstanceInDOM(),
            n = 0 === this.getInstancesInDOM().length;
        let r = e.getCurrentTrackIndex() + (t ? 1 : -1),
            o = e,
            l = !0;
        if (a || n) switch (!0) {
            case r >= 0 && r < e.getTrackCount():
                break;
            case t && r >= e.getTrackCount() && this.getOption("jump") && !!i:
                r = 0, o = i;
                break;
            case t && r >= e.getTrackCount() && !!e.repeat:
                r = 0;
                break;
            case !t && r < 0 && this.getOption("jump") && !!s:
                o = s, r = s.getTrackCount() - 1;
                break;
            default:
                l = !1
        } else o = i, r = 0;
        const d = e.id !== o.id;
        l ? (o.mousePosition = -1, o.currentTrack >= 0 && o.currentTrack < o.getTrackCount() && o.updateStatistics(), o.currentTrack = r, this.pause().then(() => {
            d ? (e.stop(), e.reset(), o.node.scrollIntoView({
                behavior: "smooth",
                block: "center"
            }), o.waveRedraw(), this.setCurrentInstance(o, !0), o.preloadTrack(!0)) : (o.preloadTrack(!0), this.setSkipState())
        })) : (o.stop(), o.reset())
    }
    applyTemplate(t, e) {
        const s = document.querySelector("#tmpl-placeholders"),
            i = this;
        if (!s) return "";
        const {
            vars: a,
            template: n
        } = this;
        return t = t.replace(/(\{[^\}]*\})/g, function(t, s) {
            var i = JSON.parse(s);
            for (let t in i) {
                let s = i[t];
                "string" == typeof i[t] && (i[t] = s.replace(/%([^%]+)%/g, function(t, s) {
                    return e[s] ? e[s] : ""
                }))
            }
            return JSON.stringify(i)
        }), t = t.replace(/%([^ %\{]*)(\{[^\}]*\})*%/g, function(t, r, o) {
            var l = r,
                d = jQuery.extend({
                    class: "",
                    showValue: 1,
                    text: "",
                    raw: 0,
                    url: "",
                    target: "_blank",
                    icon: "",
                    event: "",
                    guests: !0
                }, o ? JSON.parse(o) : "");
            try {
                const t = n(s.innerHTML);
                return t({
                    key: l,
                    attributes: d,
                    track: e,
                    loggedUser: a.currentUser.ID > 0,
                    __: i.__,
                    _n: i._n
                })
            } catch (t) {
                return ""
            }
        }), t
    }
    toggleStickyPlayer(t = !1) {
        if (!this.node) return;
        const e = document.querySelector("html");
        if (t && e.classList.contains("has-sticky-player")) return;
        const s = this.getOption("sticky_player_position");
        e.classList.toggle("has-sticky-player"), e.classList.toggle(`has-sticky-player-${s}`), this.setSkipState()
    }
    hasStickyPlayer() {
        return document.querySelector("html").classList.contains("has-sticky-player")
    }
    updateStickyPlayerInfo() {
        if (!this.hasStickyPlayer()) return;
        const t = this.getCurrentInstance();
        if (!t) return;
        const e = this.node,
            s = this.getOption("sticky_template") || "%thumbnail% %title% %artist% %share%",
            i = t.getTrack();
        if (i) {
            if (e) {
                e.querySelector(".wvpl-duration").textContent = i.length_formatted, e.querySelector(".wvpl-position").textContent = this.secondsToTime(), i.length_formatted && (e.querySelector(".wvpl-duration").style.width = `${i.length_formatted.length+1}ch`, e.querySelector(".wvpl-position").style.width = `${i.length_formatted.length+1}ch`);
                const t = e.querySelector(".wvpl-trackinfo");
                t && (t.innerHTML = this.applyTemplate(s, i))
            }
            if ("mediaSession" in navigator) {
                const t = {
                    title: i.title,
                    artist: i.artist,
                    album: i.album
                };
                i.poster && (t.artwork = [{
                    src: i.poster
                }]), navigator.mediaSession.metadata = new MediaMetadata(t)
            }
        }
    }
    updateVariationForm(t) {
        t.product_variations;
        const e = this.variationPopup.querySelector(".wvpl-variation-form");
        this.variationPopupOvserver.track = t, e.innerHTML = t.product_variations_form;
        const s = document.createElement("div");
        s.classList.add("close-button"), e.prepend(s);
        const i = jQuery(`<h4>${t.product_title}</h4>`).get(0);
        e.prepend(i), s.addEventListener("click", e => {
            document.body.classList.remove("wvpl-variation-popup"), this.trigger("variationForm:close", {
                track: t
            })
        }), this.trigger("variationForm:open", {
            track: t
        })
    }
    variationFormCallback(t, e) {
        for (let e of t)
            if ("childList" === e.type && e.target.classList.contains("wvpl-variation-form")) {
                const t = e.target.querySelector(".variations_form");
                if (t) {
                    jQuery(t).wc_variation_form();
                    const e = jQuery(t).find("table"),
                        s = jQuery(t).find("a.reset_variations");
                    s.insertAfter(e)
                }
            }
    }
    updateTrackCartStatus(t, e = "add") {
        this.instances.filter(e => e.tracks.find(e => e.product_id == t));
        for (const s of this.instances) {
            const i = s.tracks.find(e => e.product_id == t);
            i && (i.in_cart = "add" === e)
        }
    }
    setSkipState() {
        const t = this.node && this.node.querySelector(".wvpl-prev"),
            e = this.node && this.node.querySelector(".wvpl-next"),
            s = this.getCurrentInstance(),
            i = s && (this.prevInstance() || s.getCurrentTrackIndex() > 0),
            a = s && (this.nextInstance() || s.getCurrentTrackIndex() < s.getTrackCount() - 1 || s.repeat);
        try {
            this.updateStickyPlayerInfo(), t && t.classList.toggle("wvpl-disabled", !i), e && e.classList.toggle("wvpl-disabled", !a), s.setSkipState()
        } catch (t) {
            this.log("setSkipState (Engine)", t)
        }
    }
    createAnalyser() {
        if (!this.isMediaElement()) {
            this.analyser = this.audioCtx.createAnalyser(), this.analyser.smoothingTimeConstant = parseFloat(this.getOption("wave_animation") || 1), this.analyser.maxDecibels = -30, this.analyser.minDecibels = -90;
            try {
                this.analyser.fftSize = 8192
            } catch (t) {
                this.analyser.fftSize = 2048
            }
            this.analyserGain.connect(this.analyser)
        }
    }
    destroyAnalyser() {
        this.isMediaElement() || (this.analyserGain.disconnect(this.analyser), this.analyser = null, this.frequencyData = null)
    }
    createSource() {
        this.isMediaElement() || (this.source = this.audioCtx.createMediaElementSource(this.webAudio), this.source.connect(this.gain), this.source.connect(this.analyserGain), this.gain.connect(this.audioCtx.destination), this.createAnalyser())
    }
    getCurrentTrack() {
        return this.getCurrentInstance().getCurrentTrack()
    }
    audioProcess() {
        if (this.isPaused() || this.isDocumentHidden()) return;
        this.afRequest = this.requestAnimationFrame(this, this.audioProcess), this.isWebAudio() && this.analyser && parseFloat(this.getOption("wave_animation")) < 1 && (this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount), this.analyser.getByteFrequencyData(this.frequencyData));
        const t = this.getCurrentInstance();
        t && t.timeUpdate()
    }
    async ajaxCall(t, e = {}) {
        const s = this.vars.wvpl_ajax_url.replace("%%endpoint%%", t),
            i = Object.keys(e).map(t => encodeURIComponent(t) + "=" + encodeURIComponent(e[t])).join("&");
        try {
            const t = await fetch(s, {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded; charset=utf-8"
                },
                body: i
            });
            try {
                const e = await t.json();
                return e
            } catch (t) {
                this.log(t)
            }
        } catch (t) {
            this.log(t)
        }
    }
    async getAudioData(t, e, s) {
        try {
            const e = await fetch(t),
                i = e.headers.get("Content-Length");
            if (i) {
                const t = new Uint8Array(i);
                let a = 0;
                const n = e.body.getReader();
                for (;;) try {
                    const {
                        done: e,
                        value: r
                    } = await n.read();
                    if (e) break;
                    t.set(r, a), a += r.length, s(a, i)
                } catch (t) {
                    return this.log(t), !1
                }
                return t.buffer
            } {
                const t = await e.arrayBuffer();
                return t
            }
        } catch (t) {
            return this.log(t), !1
        }
    }
    decodeAudioData(t, e) {
        this.audioCtx.decodeAudioData(t, e.bind(this))
    }
    extractPeaks(t) {
        const e = t.numberOfChannels,
            s = t.length / this.peakLength,
            i = ~~(s / 10) || 1,
            a = [];
        for (var n = 0; n < e; n++) {
            const e = [],
                p = t.getChannelData(n);
            for (var r = 0; r < this.peakLength; r++) {
                for (var o = ~~(r * s), l = ~~(o + s), d = p[0], c = p[0], h = o; h < l; h += i) {
                    var u = p[h];
                    u > c && (c = u), u < d && (d = u)
                }
                e[2 * r] = c, e[2 * r + 1] = d, (0 == n || c > a[2 * r]) && (a[2 * r] = Math.abs(c.toFixed(2))), (0 == n || d < a[2 * r + 1]) && (a[2 * r + 1] = Math.abs(d.toFixed(2)))
            }
        }
        return a
    }
    readPeaks(t) {
        return t.split(",").map(t => Number(t))
    }
    loadInstances(t) {
        t = t ? document.querySelector(t) : document;
        let e = t.querySelectorAll(".waveplayer:not(.active)");
        if (e.length) {
            let t, s;
            for (let i of e) {
                this.removeInstance(i.dataset.instance_id);
                const e = document.querySelector(`#data-${i.dataset.instance_id}`);
                e ? e.dataset.tracks && (t = JSON.parse(atob(e.dataset.tracks)), s = e.dataset.nonce, e.remove()) : i.dataset.tracks && (t = JSON.parse(atob(i.dataset.tracks)), s = i.dataset.nonce, i.removeAttribute("data-tracks")), t && t.length > 0 && this.addInstance(i, t, s)
            }
        }
        this.redrawAllInstances()
    }
    stickyPlayerInit() {
        if (!this.node) return;
        const t = this.node.querySelector("#wvpl-sticky-player .wvpl-waveform");
        if (!t) return;
        const e = document.createElement("canvas");
        t.innerHTML = "", t.appendChild(e)
    }
    navigatorInit() {
        "mediaSession" in navigator && (navigator.mediaSession.setActionHandler("previoustrack", () => {
            this.skip(!1)
        }), navigator.mediaSession.setActionHandler("nexttrack", () => {
            this.skip()
        }))
    }
    isPaused() {
        return this.audio().paused
    }
    play(t) {
        const e = this.getCurrentTrack();
        this.audioPaused = !1, this.seeking(), encodeURI(this.audio().src) !== encodeURI(e.file) ? (this.persistentTrack = e, this.status = 0, this.isWebAudio() && (this.fadeTimeout && (clearTimeout(this.fadeTimeout), this.gain.gain.cancelScheduledValues(this.audioCtx.currentTime)), this.analyserFadeTimeout && (clearTimeout(this.analyserFadeTimeout), this.analyserGain.gain.cancelScheduledValues(this.audioCtx.currentTime))), this.audio().src = e.file, this.audio().play().then(() => {
            this.thenPlay(t)
        }).catch(s => {
            this.audioType = "MediaElement", this.audio().src = e.file, this.audio().play().then(() => {
                this.thenPlay(t)
            }).catch(() => {
                this.failedAttempts < WVPL_MAX_FAILED_ATTEMPTS && (this.failedAttempts++, this.tryReloadingTrack())
            })
        })) : this.audio().play().then(() => {
            this.thenPlay(t)
        })
    }
    thenPlay(t) {
        this.playing(), this.failedAttempts = 0, t >= 0 && this.setCurrentTime(t), this.toggleStickyPlayer(!0), this.isWebAudio() && (this.trackLastStart = this.getCurrentTime(), this.fadeIn(.1), this.analyserFadeIn(.3))
    }
    pause() {
        return new Promise((t, e) => {
            this.audioPaused = !0, this.lastTime = this.audio().currentTime, this.node && this.node.classList.remove("playing"), this.status > 0 ? (this.status = 2, this.isWebAudio() ? (this.fadeOut(.1), this.analyserFadeOut(.3, () => {
                this.webAudio.pause(), this.setCurrentTime(this.lastTime), this.hasEnded || this.trigger("pause"), t()
            })) : (this.mediaElement.pause(), t())) : t()
        })
    }
    stop() {
        this.pause().then(() => {
            this.status = 0, this.setCurrentTime(0)
        })
    }
    toggle() {
        const t = this.getCurrentInstance();
        this.isPaused() ? t.play() : t.pause()
    }
    resume() {
        this.audioCtx && this.audioCtx.resume()
    }
    tryReloadingTrack() {
        const t = this.getInstanceById(),
            e = t.tracks[t.currentTrack];
        e && "soundcloud" !== e.type || (e.file = "", t.preloadTrack(!0))
    }
    getCurrentTime() {
        return this.audioPaused ? this.lastTime : this.audio().currentTime
    }
    setCurrentTime(t, e = !1) {
        this.trackLastStart = t, t >= 0 && t <= this.getDuration() && (this.audio().currentTime = t), this.isPaused() && e && this.play()
    }
    getDuration() {
        return this.audio().duration
    }
    getProgress() {
        return this.getCurrentTime() / this.getDuration()
    }
    getVolume() {
        return this.volume
    }
    setVolume(t) {
        const e = [];
        this.isInstanceInDOM() && e.push(this.getCurrentInstance().node), this.hasStickyPlayer() && e.push(this.node);
        for (const s of e) {
            const e = s.querySelector(".wvpl-volume-slider .value"),
                i = s.querySelector(".wvpl-volume-slider .handle");
            e && (e.style.width = `${100*t}%`), i && (i.style.left = `${100*t}%`)
        }
        this.volume = t, this.isWebAudio() && this.gain.gain.setValueAtTime(t, this.audioCtx.currentTime), this.muted = !(t > 0)
    }
    mute() {
        this.isWebAudio() && this.gain.gain.setValueAtTime(0, this.audioCtx.currentTime), this.muted = !0
    }
    unmute() {
        this.isWebAudio() && this.gain.gain.setValueAtTime(this.volume, this.audioCtx.currentTime), this.muted = !1
    }
    toggleMute() {
        this.muted ? this.unmute() : this.mute()
    }
    isMuted() {
        return this.muted
    }
    fadeOut(t, e) {
        this.isMediaElement() ? e && e() : (this.gain.gain.setValueAtTime(this.volume, this.audioCtx.currentTime), this.gain.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + t), e && (this.fadeTimeout = setTimeout(e, 1e3 * t)))
    }
    fadeIn(t, e) {
        this.isMediaElement() ? e && e() : (this.gain.gain.setValueAtTime(0, this.audioCtx.currentTime), this.gain.gain.linearRampToValueAtTime(this.volume, this.audioCtx.currentTime + t), e && (this.fadeTimeout = setTimeout(e, 1e3 * t)))
    }
    analyserFadeOut(t, e) {
        this.isMediaElement() ? e && e() : (this.analyserGain.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime), e && (this.analyserFadeTimeout = setTimeout(e, 1e3 * t)))
    }
    analyserFadeIn(t, e) {
        this.isMediaElement() ? e && e() : (this.analyserGain.gain.linearRampToValueAtTime(this.volume, this.audioCtx.currentTime), e && (this.analyserFadeTimeout = setTimeout(e, 1e3 * t)))
    }
    isLooped() {
        return this.audio().loop
    }
    loop(t) {
        this.audio().loop = t
    }
    getSampleRate() {
        return this.audioCtx.sampleRate
    }
    setSmoothingTimeConstant(t) {
        this.isMediaElement() || (this.analyser || this.createAnalyser(), this.analyser.smoothingTimeConstant = t)
    }
    redrawAllInstances() {
        for (const t of this.getInstancesInDOM()) t.refresh();
        this.setSkipState()
    }
    playing() {
        this.audioProcess();
        const t = this.getCurrentInstance();
        t && (t.playing(), t.node.classList.remove("seeking")), this.node && (this.node.classList.remove("seeking"), this.node.classList.add("playing")), this.trigger("seeking"), this.status = 1
    }
    seeking() {
        const t = this.getCurrentInstance();
        t && t.node.classList.add("seeking"), this.node && this.node.classList.add("seeking"), this.trigger("seeking")
    }
    seeked() {
        const t = this.getCurrentInstance();
        t && t.node.classList.remove("seeking"), this.node && this.node.classList.remove("seeking"), this.trigger("seeked")
    }
    addEvents() {
        this.onSeeking(), this.onSeeked(), this.onEnded(), this.onTimeUpdateFallback()
    }
    onSeeking() {
        this.webAudio.addEventListener("seeking", t => {
            this.seeking()
        }), this.mediaElement.addEventListener("seeking", t => {
            this.seeking()
        })
    }
    onSeeked() {
        this.webAudio.addEventListener("seeked", t => {
            this.seeked()
        }), this.mediaElement.addEventListener("seeked", t => {
            this.seeked()
        })
    }
    onEnded() {
        this.webAudio.addEventListener("ended", t => {
            this.hasEnded = !0, this.trigger("ended")
        }), this.mediaElement.addEventListener("ended", t => {
            this.hasEnded = !0, this.trigger("ended")
        })
    }
    onTimeUpdateFallback() {
        this.mediaElement.addEventListener("timeupdate", t => {
            const e = this.getCurrentInstance();
            e && e.timeUpdate()
        })
    }
    gtmPushTimeData(t) {
        window.dataLayer = window.dataLayer || [];
        const e = this.getCurrentInstance().getTrack(),
            s = this.round(this.getCurrentTime(), 2);
        if (!e) return;
        const i = {
            event: "track",
            action: t,
            type: "time",
            trackId: e.id || 0,
            trackTitle: e.title || "",
            time: s || 0
        };
        window.dataLayer.push(i)
    }
    gtmPushSegmentData(t) {
        window.dataLayer = window.dataLayer || [];
        const e = this.getCurrentTrack(),
            s = this.round(this.getCurrentTime(), 2);
        if (!e) return;
        const i = {
            event: "track",
            action: t,
            type: "segment",
            trackId: e.id || 0,
            trackTitle: e.title || "",
            time: s || 0,
            from: this.round(this.trackLastStart, 2),
            duration: this.round(s - this.trackLastStart)
        };
        window.dataLayer.push(i)
    }
    round(t, e) {
        e = e || 0;
        const s = Math.pow(10, e),
            i = Number.EPSILON || Math.pow(2, -52);
        return Math.round(t * s + i) / s
    }
    trigger(t, e) {
        const s = this.getCurrentInstance();
        s && this.getCurrentInstance().trigger(t, e)
    }
    secondsToTime(t) {
        if (null == t) return "0:00";
        t = Math.round(t);
        var e = t % 60,
            s = Math.floor(t / 60) % 60,
            i = Math.floor(t / 3600);
        return (i > 0 ? i + ":" : "") + (i > 0 && s < 10 ? "0" : "") + s + ":" + (e < 10 ? "0" : "") + e
    }
    timeToSeconds(t) {
        const e = t.match(/((1*[0-2]|0*[0-9]):)?([0-5]*[0-9]):([0-5][0-9])/);
        if (e) {
            let t = Number(e[4]);
            return e[3] && (t += 60 * Number(e[3])), e[2] && (t += 3600 * Number(e[2])), t
        }
        return !1
    }
    shortenNumber(t) {
        t = Number(t);
        const e = ["", "k", "M", "G", "T", "P", "E"];
        let s = 0;
        for (; t >= 1e3;) t /= 1e3, s++;
        return t.toFixed(0) + e[s]
    }
    isDebugMode() {
        return this.vars.is_script_debug
    }
    log(...t) {
        this.isDebugMode() && console.debug(...t)
    }
}
const WVPL_STATUS_STOP = 0,
    WVPL_STATUS_PLAY = 1,
    WVPL_STATUS_PAUSE = 2,
    WVPL_ANIMATION_TIME = 300;
class WVPLInstance {
    constructor(t, e, s, i) {
        this.id = t.dataset.instance_id, this.node = t, this.engine = i, this.tracks = e, this.currentTrack = 0, this.nonce = s, this.waveformOptions = null, this.runtime = 0, this.info = this.getData("info"), this.lastStart = 0, this.scrolling = !1, this.timerOverlay, this.startOffset, this.startVol, this.mousePosition = -1, this.status = WVPL_STATUS_STOP, this.createObservers(), this.instanceInit()
    }
    getOption(t) {
        const e = this.engine.getOption(t) || "";
        return e
    }
    getData(t) {
        let e = this.node.dataset[t];
        return void 0 !== e && 0 !== e.toString().length || (e = this.getOption(t)), e
    }
    getStickyPlayerData(t) {
        if (!this.engine.node) return;
        let e = void 0;
        return e = getComputedStyle(this.engine.node).getPropertyValue(`--${t}`).trim(), e
    }
    updateLength() {
        this.getFirst(".wvpl-duration") && (this.getFirst(".wvpl-duration").textContent = this.getTrackData("length_formatted"), this.getFirst(".wvpl-position").textContent = this.engine.secondsToTime(), this.getTrackData("length_formatted") && (this.getFirst(".wvpl-duration").style.width = `${this.getTrackData("length_formatted").length+1}ch`, this.getFirst(".wvpl-position").style.width = `${this.getTrackData("length_formatted").length+1}ch`))
    }
    getRealWaveformSize(t) {
        t = t || this.node;
        const e = t.querySelector(".wvpl-waveform");
        if (!e) return !1;
        getComputedStyle(e);
        let s = e.clientHeight,
            i = e.clientWidth;
        if (i * s > 0) return {
            width: i,
            height: s
        };
        let a = e,
            n = a;
        for (;
            (n = n.parentNode) && !(n.offsetWidth * n.offsetHeight > 0);) a = n;
        if (n) {
            let t = a.cloneNode(!0);
            t.style.display = "block", n.append(t);
            let e = t.querySelector(".wvpl-waveform");
            e && (i = e.offsetWidth, s = e.offsetHeight), t.remove()
        }
        return {
            width: i,
            height: s
        }
    }
    getWaveformOptions(t) {
        t = t || this.node;
        const e = t.querySelector(".wvpl-waveform");
        if (!e) return !1;
        const s = t === this.engine.node,
            i = s ? this.getOption.bind(this) : this.getData.bind(this);
        return {
            waveColor: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--wave").trim() + ")" : i("wave_color"),
            waveColor2: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--wave-shade").trim() + ")" : i("wave_color_2"),
            progressColor: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--progress").trim() + ")" : i("progress_color"),
            progressColor2: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--progress-shade").trim() + ")" : i("progress_color_2"),
            cursorColor: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--cursor").trim() + ")" : i("cursor_color"),
            cursorColor2: parseInt(i("override_wave_colors")) ? "rgb(" + getComputedStyle(t).getPropertyValue("--cursor-shade").trim() + ")" : i("cursor_color_2"),
            cursorWidth: parseInt(i("cursor_width")),
            hoverOpacity: parseInt(i("hover_opacity")) / 100,
            barWidth: parseInt(i("wave_mode")),
            gapWidth: parseInt(i("gap_width")),
            compression: parseInt(i("wave_compression")),
            asymmetry: parseInt(i("wave_asymmetry")),
            normalization: parseInt(i("wave_normalization")),
            waveAnimation: parseFloat(this.getData("wave_animation")),
            ampFreqRatio: parseFloat(this.getData("amp_freq_ratio")),
            height: e.offsetHeight,
            bandwidth: 2e4,
            bandwidthStart: 100
        }
    }
    updateSize(t) {
        const e = [];
        (t || this.engine.isInstanceInDOM(this.id)) && e.push({
            player: this.node,
            instance: this
        }), (t || this.engine.hasStickyPlayer()) && e.push({
            player: this.engine.node,
            instance: this.engine.getCurrentInstance()
        });
        for (const t of e) {
            const e = t.player;
            if (!e || !e.querySelector(".wvpl-waveform")) continue;
            e.waveformOptions = this.getWaveformOptions(e), this.engine.setSmoothingTimeConstant(parseFloat(this.getData("wave_animation") || 1));
            let s = e.querySelector(".wvpl-waveform canvas"),
                i = s.getContext("2d"),
                a = this.getRealWaveformSize(e);
            try {
                i.canvas.width = Math.round(a.width * window.devicePixelRatio), i.canvas.height = Math.round(a.height * window.devicePixelRatio), s.style.width = `${Math.round(a.width)}px`, s.style.height = `${Math.round(a.height)}px`
            } catch (t) {
                this.log("updateSize", t)
            }
            this.prepareCanvas(e), this.getTrackData("peaks") && this.calculateWaveParams(e)
        }
    }
    prepareCanvas(t) {
        t = t || this.node;
        const e = t.querySelector(".wvpl-waveform canvas"),
            s = e.getContext("2d");
        e.grdW = this.createGradient(s, s.canvas.height, t.waveformOptions.waveColor, t.waveformOptions.waveColor2, t.waveformOptions.asymmetry), e.grdP = this.createGradient(s, s.canvas.height, t.waveformOptions.progressColor, t.waveformOptions.progressColor2, t.waveformOptions.asymmetry), e.grdC = s.createLinearGradient(0, 0, 0, s.canvas.height);
        try {
            e.grdC.addColorStop(0, t.waveformOptions.cursorColor), e.grdC.addColorStop(1, t.waveformOptions.cursorColor2)
        } catch (t) {
            this.log("prepareCanvas", t)
        }
    }
    createGradient(t, e, s, i, a) {
        let n = t.createLinearGradient(0, 0, 0, e);
        try {
            n.addColorStop(0, s), n.addColorStop(a / (1 + a) - 1e-9, i), n.addColorStop(a / (1 + a), s), n.addColorStop(1, i)
        } catch (t) {
            this.log("createGradient", t)
        }
        return n
    }
    clearWave(t) {
        t = t || this.node;
        let e = t.querySelector(".wvpl-waveform canvas"),
            s = e.getContext("2d");
        s.clearRect(0, 0, s.canvas.width, s.canvas.height)
    }
    waveformInit() {
        let t = this.getFirst(".wvpl-waveform"),
            e = document.createElement("canvas");
        t && (t.innerHTML = "", t.appendChild(e))
    }
    processBuffer(t, e) {
        if (!t || t.constructor !== ArrayBuffer) return !1;
        this.engine.decodeAudioData(t, t => {
            const s = this.engine.extractPeaks(t);
            this.getTrackData("length") || (this.setTrackData("length", t.duration), this.setTrackData("length_formatted", this.engine.secondsToTime(t.duration))), this.setTrackData("peaks", s), this.updateInfo(), this.trigger("peaksloaded", {
                peaks: s,
                id: e
            })
        })
    }
    progressCallback(t, e) {
        const s = Math.floor(100 * t / e);
        this.updateOverlay(s, "audio analysis in progress&hellip;")
    }
    waveReset() {
        this.clearWave(), this.engine.node && this.clearWave(this.engine.node)
    }
    calculateWaveParams(t) {
        t = t || this.node;
        const e = {},
            s = window.devicePixelRatio;
        e.canvas = t.querySelector(".wvpl-waveform canvas"), e.cCtx = e.canvas.getContext("2d"), e.width = e.canvas.width, e.height = e.canvas.height, e.barWidth = 0 == t.waveformOptions.barWidth ? 1 * s : t.waveformOptions.barWidth * s, e.gapWidth = 0 == t.waveformOptions.gapWidth ? 0 : t.waveformOptions.gapWidth * s, e.cursorWidth = t.waveformOptions.cursorWidth * s, e.compRatio = 1 / t.waveformOptions.compression, e.a = t.waveformOptions.asymmetry, e.stepSize = e.barWidth + e.gapWidth;
        const i = this.getTrackData("peaks");
        e.scale = e.width / i.length, e.max = 1, i && t.waveformOptions.normalization && (e.max = Math.max(...i)), t.waveParams = e
    }
    drawWave() {
        const t = [];
        this.engine.isInstanceInDOM(this.id) && t.push({
            player: this.node,
            instance: this
        }), this.engine.hasStickyPlayer() && t.push({
            player: this.engine.node,
            instance: this.engine.getCurrentInstance()
        });
        for (const i of t) {
            const t = i.player,
                a = i.instance;
            if (!t || !a || !t.querySelector(".wvpl-waveform")) continue;
            const n = a.getTrackData("peaks"),
                r = this.status !== WVPL_STATUS_STOP ? this.engine.getCurrentTime() : 0,
                o = this.status !== WVPL_STATUS_STOP ? this.engine.getProgress() : 0;
            let l = this.status !== WVPL_STATUS_STOP ? this.engine.frequencyData : null;
            if (!n) return;
            const d = t.querySelector(".wvpl-position");
            d && (d.textContent = this.engine.secondsToTime(r));
            const c = t.waveParams,
                h = t.waveformOptions,
                u = t === this.node ? this.mousePosition : -1,
                {
                    scale: p,
                    max: g
                } = c,
                m = o * c.width;
            let v = h.ampFreqRatio;
            1 == h.waveAnimation && (v = 1 / 0);
            const f = h.bandwidthStart * c.width / h.bandwidth;
            c.width, c.width;
            c.cCtx.clearRect(0, 0, c.width, c.height);
            const w = devicePixelRatio,
                y = 1 / (v + 1),
                T = 1 - y;
            let k = 0;
            for (var e = 0; e < c.width - c.stepSize; e += c.stepSize) {
                const i = l ? Math.round(Math.max(k, Math.pow(l.length, e / c.width))) : 0,
                    a = l ? g * l[i] / 255 : 0,
                    r = Math.pow(Math.abs(n[Math.floor(e / p)]), c.compRatio),
                    o = Math.max(w, Math.abs(Math.ceil(c.height * (T * r + y * a) / g)));
                c.cCtx.fillStyle = c.canvas.grdW;
                var s = Math.ceil(c.a * (c.height - o) / (1 + c.a));
                c.cCtx.globalAlpha = 1, c.cCtx.fillRect(e, s, c.barWidth, o), e < Math.max(u, m) && this.status !== WVPL_STATUS_STOP && (c.cCtx.fillStyle = c.canvas.grdP, c.cCtx.globalAlpha = 1, u >= 0 && e > Math.min(u, m) && t === this.node && (c.cCtx.globalAlpha = h.hoverOpacity), c.cCtx.fillRect(e, s, c.barWidth, o)), k++
            }
            this.status !== WVPL_STATUS_STOP && (c.cCtx.fillStyle = c.canvas.grdC, c.cCtx.fillRect(m, 0, c.cursorWidth, c.height))
        }
    }
    waveRedraw() {
        this.updateSize(!0), this.drawWave(!0)
    }
    timeUpdate() {
        this.drawWave(), this.trigger("timeupdate")
    }
    createObservers() {
        const t = {
            attributes: !0,
            childList: !1,
            subtree: !1,
            attributeOldValue: !0
        };
        this.mutationObserver = new MutationObserver((t, e) => {
            for (let e of t)
                if ("attributes" === e.type && e.oldValue !== this.node.getAttribute(e.attributeName)) break
        }), this.mutationObserver.observe(this.node, t), window.ResizeObserver && (this.resizeObserver = new ResizeObserver(t => {
            const e = t.find(t => t.target.dataset.instance_id === this.id);
            e && this.currentWidth !== e.target.offsetWidth && (this.currentWidth = e.target.offsetWidth, this.refresh())
        }), this.resizeObserver.observe(this.node)), window.IntersectionObserver && (this.intersectionObserver = new IntersectionObserver(t => {
            !0 !== t[0].isIntersecting || t[0].target.classList.contains("wvpl-rendered") || this.playerInit()
        }, {
            threshold: [0]
        }), this.intersectionObserver.observe(this.node))
    }
    instanceInit() {
        const t = this.getFirst(".wvpl-playlist-wrapper"),
            e = (this.getFirst(".wvpl-playlist"), this.getFirst(".wvpl-play"), this.getFirst(".wvpl-position")),
            s = this.getFirst(".wvpl-duration");
        t && (t.innerHTML = "");
        let i = parseInt(this.getData("wave_asymmetry"));
        i = 100 * i / (1 + i), e && (e.style.top = i + "%", s.style.top = i + "%");
        let a = document.querySelectorAll(".waveplayer"),
            n = 0;
        this.parentElement;
        for (n = 0; n < a.length && a[n] != this.node; n++);
        this.waveformInit(), this.autoplay = !!Number(this.getData("autoplay")), this.repeat = !!Number(this.getData("repeat")), this.shuffle = !!Number(this.getData("shuffle")), this.activated(), window.IntersectionObserver || this.playerInit()
    }
    playerInit(t) {
        if (!this.node.classList.contains("wvpl-rendered"))
            if (this.getTrackCount() > 0) {
                const e = this.getTrack(),
                    s = e.id,
                    i = (e.filesize, e.temp_file);
                this.node.classList.add("wvpl-rendered"), this.loading(), this.currentTrack = 0, i ? (this.analyzing(), this.engine.getAudioData(i, s, this.progressCallback.bind(this)).then(t => {
                    this.processBuffer(t, s)
                })) : (this.setInfoState(), this.displayPlaylist(), this.preloadTrack(t)), this.initEvents()
            } else playBtn && playBtn.classList.add("wvpl-disabled"), this.node.classList.add("wvpl-hidden")
    }
    getCurrentTime() {
        return this.engine.getCurrentTime()
    }
    setCurrentTime(t) {
        if (t < 0 || t > this.engine.getDuration()) return !1;
        this.engine.setCurrentTime(t)
    }
    maybeSwitch() {
        return new Promise((t, e) => {
            this.id !== this.engine.getCurrentId() ? (this.engine.node && this.engine.node.classList.add("loading"), this.trigger("skip"), this.engine.pause().then(() => {
                this.engine.setCurrentInstance(this, !0);
                this.engine.getCurrentInstance();
                this.preloadTrack(), t()
            })) : e()
        })
    }
    play() {
        this.maybeSwitch().then(() => (this.engine.node && this.engine.node.classList.remove("loading"), this.lastStart = (new Date).getTime(), this.engine.play()), () => (this.lastStart = (new Date).getTime(), this.engine.play())).catch(() => (this.lastStart = (new Date).getTime(), this.engine.play()))
    }
    pause() {
        this.engine.pause(), this.paused(), this.waveRedraw()
    }
    stop() {
        if (this.status == WVPL_STATUS_STOP) return !1;
        this.engine.stop(), this.paused(), this.getFirst(".wvpl-position") && (this.getFirst(".wvpl-position").textContent = this.engine.secondsToTime(0)), this.status = WVPL_STATUS_STOP, this.waveRedraw()
    }
    skip(t = !0) {
        this.clicked = !0;
        const e = this.endOfPlaylist(t);
        this.stop(), this.endOfPlaylist(t) && (this.currentTrack = 0), this.engine.currentId !== this.id && this.engine.setCurrentInstance(this, !0), this.loading(e), setTimeout(() => {
            this.engine.skip(t)
        }, WVPL_ANIMATION_TIME)
    }
    skipTo(t) {
        if (null == t || t < 0 || t >= this.getTrackCount()) return !1;
        if (t == this.currentTrack) return this.status !== WVPL_STATUS_PLAY && this.play(), !0;
        const e = this.engine.getCurrentInstance();
        e && e.node.id === this.node.id || (this.pause(), this.engine.setCurrentInstance(this, !0)), this.currentTrack = t - 1, this.skip()
    }
    endOfPlaylist(t = !0) {
        const e = t && this.currentTrack === this.tracks.length - 1 || !t && 0 === this.currentTrack || 1 === this.tracks.length;
        return e && !this.repeat
    }
    scrollTo(t, e) {
        let s = this.getFirst(".wvpl-playlist"),
            i = this.getChildren(".wvpl-playlist-wrapper>ul>li"),
            a = i[t];
        if (!a) return !1;
        e ? a.offsetTop + a.height > s.scrollTop + s.height && s.animate({
            scrollTop: a.offsetTop + a.outerHeight - s.outerHeight
        }) : a.offsetTop < s.scrollTop && s.animate({
            scrollTop: a.offsetTop
        })
    }
    analyzing() {
        this.node.classList.remove("loading"), this.node.classList.add("analyzing"), this.trigger("analyzing")
    }
    analyzed() {
        this.node.classList.remove("analyzing"), this.updateOverlay(0, ""), this.trigger("analyzed", {
            track: this.getTrack(),
            peaks: this.getTrackData("peaks")
        })
    }
    loading(t) {
        t || (this.node.classList.add("loading"), this.trigger("loading")), this.engine.node && this.engine.node.classList.add("loading")
    }
    loaded() {
        this.node.classList.remove("loading"), this.engine.node && this.engine.node.classList.remove("loading"), this.waveRedraw(), this.trigger("loaded")
    }
    playing() {
        this.status = WVPL_STATUS_PLAY, this.removeClassFrom(".wvpl-playlist li", "playing");
        let t = this.getChildren(".wvpl-playlist-wrapper>ul>li");
        t.length && (t[this.currentTrack].classList.add("playing"), this.getData("scrollPlaylistItemIntoView") && t[this.currentTrack].scrollIntoView({
            behavior: "smooth",
            block: "center"
        })), this.node.classList.add("playing")
    }
    paused() {
        this.status = WVPL_STATUS_PAUSE, this.runtime += (new Date).getTime() - this.lastStart, this.node.classList.remove("playing", "loading", "seeking"), this.engine.node && this.engine.node.classList.remove("playing", "loading", "seeking"), this.removeClassFrom(".wvpl-playlist li", "playing")
    }
    ready() {
        this.loaded(), this.trigger("ready", {
            instance: this,
            track: this.getTrack()
        })
    }
    activated(t = "") {
        this.node.classList.add("active"), t && this.node.classList.add(t), this.trigger("activated", {
            id: this.id
        })
    }
    resize() {
        const t = this.node.offsetWidth,
            e = [{
                width: 400,
                class: "sqxxs"
            }, {
                width: 600,
                class: "sqxs"
            }, {
                width: 800,
                class: "sqsm"
            }, {
                width: 1e3,
                class: "sqmd"
            }, {
                width: 1200,
                class: "sqlg"
            }, {
                width: 1 / 0,
                class: "sqxl"
            }];
        let s = "";
        for (const i of e)
            if (s = i.class, t < i.width) break;
        this.node.classList.remove(...e.map(t => `wvpl-${t.class}`)), this.node.classList.add(`wvpl-${s}`)
    }
    refresh() {
        this.resize(), this.setSkipState(), this.waveRedraw()
    }
    preloadTrack(t = !1) {
        if (this.currentTrack < 0 && (this.currentTrack = 0), this.engine.loop(1 == this.getTrackCount() && this.repeat), "soundcloud" !== this.getTrackData("type") || this.getTrackData("file")) {
            const e = this.getTrackData("peak_file");
            !this.getTrackData("peaks") && e ? fetch(e).then(t => t.text()).then(e => {
                let s = [];
                s = "external" === this.getTrackData("type") ? JSON.parse(e).peaks : e, s && (s = this.engine.readPeaks(s), this.setTrackData("peaks", s), this.preloadFile(t))
            }) : this.preloadFile(t)
        } else fetch(`${this.engine.vars.sc_api_url}tracks/${this.getTrackData("id")}/streams`, {
            headers: {
                Authorization: `OAuth ${this.engine.vars.sc_access_token}`
            }
        }).then(t => t.json(), t => this.log(t)).then(e => {
            void 0 !== e && e.http_mp3_128_url ? (this.setTrackData("file", e.http_mp3_128_url), this.preloadFile(t)) : (this.log(`${e.code}: ${e.message}`), this.removeTrack(this.currentTrack), this.preloadTrack(t))
        }, t => this.log(t))
    }
    updateOverlay(t, e) {
        const s = this.overlay || this.getFirst(".wvpl-overlay");
        s && (s.querySelector(".percentage").innerHTML = t ? `${t}%` : "&nbsp;", s.querySelector(".wvpl-loading>div").style.width = `${t}%`, s.querySelector(".message").innerHTML = this.engine.__(e, "waveplayer")), this.overlay = s
    }
    preloadFile(t) {
        if (this.updateInfo(), this.getTrackData("peaks")) this.loaded(), (t || this.status === WVPL_STATUS_PLAY) && this.play();
        else {
            this.pause(), this.analyzing();
            const t = this.getTrack(),
                e = t.id,
                s = t.file;
            t.filesize, t.temp_file;
            if ("external" !== this.getTrackData("type")) this.engine.getAudioData(s, e, this.progressCallback.bind(this)).then(t => {
                this.processBuffer(t, e)
            });
            else {
                this.updateOverlay(0, "creating a local copy of the file&hellip;");
                const t = {
                    nonce: this.engine.vars.ajax_nonce,
                    url: s
                };
                this.engine.ajaxCall("create_local_copy", t).then(t => {
                    t.success ? (this.tracks[this.currentTrack] = t.data.track, this.engine.getAudioData(t.data.track.temp_file, e, this.progressCallback.bind(this)).then(t => {
                        this.processBuffer(t, e)
                    })) : this.updateOverlay(0, "An error occurred while copying the file&hellip;")
                })
            }
        }
    }
    reload() {
        this.reset()
    }
    reset() {
        this.currentTrack = 0, this.paused(), this.setSkipState(), this.preloadTrack()
    }
    toggle() {
        switch (this.status) {
            case WVPL_STATUS_PLAY:
                this.pause();
                break;
            case WVPL_STATUS_STOP:
            case WVPL_STATUS_PAUSE:
                this.play()
        }
    }
    setInfoState() {
        const t = this.getFirst(".wvpl-info"),
            e = this.getFirst(".wvpl-infobar"),
            s = this.getFirst(".wvpl-playlist"),
            i = ["none", "info"];
        this.getTrackCount() > 1 && i.push("playlist");
        const a = i[(i.indexOf(this.info) + 1) % i.length];
        switch (t && t.classList.remove("wvpl-info-none", "wvpl-info-info", "wvpl-info-playlist"), t && t.classList.add(`wvpl-info-${a}`), e && e.classList.add("wvpl-hidden"), s && s.classList.add("wvpl-hidden"), this.info) {
            case "none":
                break;
            case "info":
                e && e.classList.remove("wvpl-hidden");
                break;
            case "playlist":
                e && e.classList.remove("wvpl-hidden"), s && this.getTrackCount() > 1 && s.classList.remove("wvpl-hidden")
        }
    }
    toggleInfoState() {
        const t = ["none", "info"];
        this.getTrackCount() > 1 && t.push("playlist"), "playlist" == this.info && 1 == this.getTrackCount() && (this.info = "info"), this.info = t[(t.indexOf(this.info) + 1) % t.length], this.setInfoState()
    }
    setSkipState() {
        let t = this.getFirst(".wvpl-prev"),
            e = this.getFirst(".wvpl-next");
        switch (t && t.classList.remove("wvpl-disabled"), e && e.classList.remove("wvpl-disabled"), !0) {
            case 1 === this.getTrackCount():
                t && t.classList.add("wvpl-disabled"), e && e.classList.add("wvpl-disabled");
                break;
            case 0 === this.currentTrack:
                t && t.classList.add("wvpl-disabled");
                break;
            case this.currentTrack === this.getTrackCount() - 1:
                e && e.classList.add("wvpl-disabled")
        }
    }
    updateInfo() {
        const t = JSON.parse(JSON.stringify(this.getTrack()));
        t.stats && (t.stats.downloads = this.engine.shortenNumber(t.stats.downloads), t.stats.play_count = this.engine.shortenNumber(t.stats.play_count), t.stats.likes = this.engine.shortenNumber(t.stats.likes)), this.updateLength();
        let e = this.getData("template");
        t.thumbnail && t.thumbnail;
        e += "soundcloud" === t.type ? " %soundcloud%" : "";
        this.getFirst(".wvpl-poster");
        const s = t.poster || this.getData("default_thumbnail");
        this.node.style.setProperty("--poster-image", `url(${s})`), this.node.style.setProperty("font-size", `${this.getData("base_font_size")}px`), e = null == e ? t.title : this.engine.applyTemplate(e, t);
        const i = this.getFirst(".wvpl-playing-info .wvpl-infoblock");
        i && (i.innerHTML = e, e || i.classList.add("wvpl-hidden"))
    }
    displayPlaylist() {
        let t = document.createElement("ul");
        for (const e of this.tracks) {
            let s = document.createElement("li");
            const i = JSON.parse(JSON.stringify(e));
            i.stats && (i.stats.downloads = this.engine.shortenNumber(i.stats.downloads), i.stats.play_count = this.engine.shortenNumber(i.stats.play_count), i.stats.likes = this.engine.shortenNumber(i.stats.likes)), s.innerHTML = this.engine.applyTemplate(this.getData("playlist_template"), i), t.append(s)
        }
        this.getFirst(".wvpl-playlist-wrapper") && this.getFirst(".wvpl-playlist-wrapper").append(t)
    }
    updateStatistics() {
        const t = this.currentTrack,
            e = {
                nonce: this.engine.vars.ajax_nonce,
                id: this.getTrackData("id", t),
                length: this.getTrackData("length", t),
                runtime: this.runtime
            };
        if (this.runtime += (new Date).getTime() - this.lastStart, this.lastStart = (new Date).getTime(), this.runtime = 0, 0 == this.lastStart) return !1;
        this.engine.ajaxCall("update_statistics", e).then(e => {
            e.success ? this.setTrackData("stats", e.data.stats, t) : this.log(e.data.message)
        })
    }
    updateLikes(t) {
        if (0 == this.engine.vars.currentUser.ID) return !1;
        const e = document.querySelectorAll('.wvpl-likes[data-id="' + t.dataset.id + '"]');
        for (const t of e) t.classList.add("wvpl-spin");
        const s = {
            nonce: this.engine.vars.ajax_nonce,
            id: t.dataset.id
        };
        this.engine.ajaxCall("update_likes", s).then(s => {
            if (s.success) {
                this.setTrackData("liked", s.data.liked, t.dataset.index), this.setTrackData("stats", s.data.stats, t.dataset.index);
                for (const i of e) {
                    i.dataset.event = s.data.liked ? "unlike" : "like", i.classList.toggle("liked", s.data.liked), i.classList.remove("wvpl-spin");
                    const e = i.querySelector(".wvpl-value");
                    e && (e.textContent = this.engine.shortenNumber(this.getTrackData("stats", t.dataset.index).likes))
                }
            } else this.log(s.data.message)
        })
    }
    addToCart(t, e) {
        const s = t.dataset.product_id,
            i = (t.closest(".waveplayer"), this.tracks.find(t => t.product_id == s));
        let a = document.querySelectorAll('.wvpl-cart[data-product_id="' + s + '"]');
        if (a)
            if (i && i.product_variations) this.engine.updateVariationForm(i);
            else {
                this.currentTrack;
                const t = {
                    nonce: this.engine.vars.ajax_nonce,
                    product_id: s
                };
                for (const t of a) t.classList.add("wvpl-spin");
                this.engine.ajaxCall("add_to_cart", t).then(t => {
                    if (t.data.fragments) {
                        i.in_cart = 1;
                        for (const t of a) t.title = this.engine.__("Already in cart: go to cart", "waveplayer"), t.classList.remove("wvpl-spin", "wvpl-add_to_cart"), t.classList.add("wvpl-in_cart"), t.dataset.event = "goToCart", t.dataset.callback = "goToCart";
                        for (const e in t.fragments) {
                            let s = document.querySelector(e);
                            s && (s.outerHTML = t.data.fragments[e])
                        }
                        jQuery(document.body).trigger("wc_fragment_refresh"), jQuery(document.body).trigger("added_to_cart", [t.data.fragments, t.data.cart_hash]), this.engine.vars.ajax_nonce = t.data.ajax_nonce
                    } else {
                        for (const t of a) t.classList.remove("wvpl-spin");
                        this.log("addToCart", t)
                    }
                })
            }
    }
    addVariationToCart(t, e) {
        document.querySelector("#wvpl-variation-popup");
        const s = document.querySelectorAll('.wvpl-cart[data-product_id="' + e + '"]'),
            i = {
                nonce: this.engine.vars.ajax_nonce,
                product_id: t
            },
            a = this.tracks.find(t => t.product_id == e);
        for (const t of s) t.classList.add("wvpl-spin");
        this.engine.ajaxCall("add_to_cart", i).then(t => {
            if (t.data.fragments) {
                a && (a.in_cart = 1);
                for (const t of s) t.title = this.engine.__("Already in cart: go to cart", "waveplayer"), t.classList.remove("wvpl-spin", "wvpl-add_to_cart"), t.classList.add("wvpl-in_cart"), t.dataset.event = "goToCart", t.dataset.callback = "goToCart";
                for (const e in t.data.fragments) {
                    let s = document.querySelector(e);
                    s && (s.outerHTML = t.data.fragments[e])
                }
                jQuery(document.body).trigger("wc_fragment_refresh"), jQuery(document.body).trigger("added_to_cart", [t.data.fragments, t.data.cart_hash]), this.engine.vars.ajax_nonce = t.data.ajax_nonce
            } else {
                for (const t of s) t.classList.remove("wvpl-spin");
                this.log("addVariationToCart", t)
            }
            document.body.classList.remove("wvpl-variation-popup")
        })
    }
    goToCart() {
        window.location = this.getData("cartURL")
    }
    updateDownloads(t, e) {
        const s = document.querySelectorAll('.wvpl-downloads[data-id="' + t.dataset.id + '"]');
        for (const t of s) t.classList.add("wvpl-spin");
        const i = t.querySelector("a.wvpl-link"),
            a = i.href,
            n = this.engine.findTrack(t.dataset.id),
            r = n ? `${n.artist} - ${n.title}.${n.fileformat}` : a;
        fetch(a).then(t => t.blob()).then(t => URL.createObjectURL(t)).then(t => {
            const e = document.createElement("a");
            e.href = t, e.download = r, e.click()
        });
        const o = {
            nonce: this.engine.vars.ajax_nonce,
            id: t.dataset.id
        };
        this.engine.ajaxCall("update_downloads", o).then(e => {
            if (e.success) {
                this.setTrackData("stats", e.data.stats, t.dataset.index), t.querySelector(".wvpl-value") && (t.querySelector(".wvpl-value").textContent = this.engine.shortenNumber(e.data.stats.downloads));
                for (const e of s) {
                    const s = e.querySelector(".wvpl-value");
                    s && (s.textContent = this.engine.shortenNumber(this.getTrackData("stats", t.dataset.index).downloads))
                }
            } else this.log(e.data.message);
            for (const t of s) t.classList.remove("wvpl-spin")
        })
    }
    socialShare(t, e) {
        var s, i = encodeURIComponent(t.dataset.url),
            a = encodeURIComponent(t.dataset.title),
            n = encodeURIComponent(this.getData("site"));
        switch (e) {
            case "fb":
                s = "https://www.facebook.com/sharer/sharer.php?display=popup&u=" + i;
                break;
            case "tw":
                s = "https://twitter.com/intent/tweet?url=" + i;
                break;
            case "ln":
                s = "https://www.linkedin.com/shareArticle?mini=true&url=" + i + "&title=" + a + "&source=" + n
        }
        window.open(s, "")
    }
    getChildren(t) {
        return this.node.querySelectorAll(t)
    }
    getFirst(t) {
        return this.node.querySelector(t)
    }
    getCurrentTrackIndex() {
        return this.currentTrack
    }
    getCurrentTrack() {
        return !!this.tracks && this.tracks[this.currentTrack]
    }
    getTrack(t) {
        return null == t && (t = this.currentTrack), !(!this.tracks || !this.tracks[t]) && this.tracks[t]
    }
    setTrack(t, e) {
        null == e && (e = this.currentTrack), this.tracks && (this.tracks[e] = t)
    }
    removeTrack(t) {
        void 0 === t && (t = this.currentTrack), this.tracks.splice(t, 1);
        const e = this.getChildren(".wvpl-playlist-wrapper>ul>li")[t];
        e && e.remove()
    }
    getTrackData(t, e) {
        if (null == e && (e = this.currentTrack), this.tracks && this.tracks[e] && this.tracks[e][t]) return this.tracks[e][t]
    }
    setTrackData(t, e, s) {
        null == s && (s = this.currentTrack), this.tracks && this.tracks[s] && (this.tracks[s][t] = e)
    }
    getTrackCount() {
        if (this.tracks) return this.tracks.length
    }
    addClassTo(t, ...e) {
        let s = this.getChildren(t);
        for (let t of s)
            for (let s of e) t.classList.add(s)
    }
    removeClassFrom(t, ...e) {
        let s = this.getChildren(t);
        for (let t of s)
            for (let s of e) t.classList.remove(s)
    }
    addEventListener(t, e) {
        this.node.addEventListener(t, e)
    }
    addEventListenerTo(t, e, s) {
        for (let i of this.getChildren(t)) i.addEventListener(e, s)
    }
    trigger(t, e) {
        e = e || {
            track: this.getTrack(),
            time: this.getCurrentTime()
        };
        let s = new CustomEvent(t, {
            detail: e,
            bubbles: !0
        });
        this.node.dispatchEvent(s);
        const i = ["play", "pause"],
            a = ["jump", "skip", "ended"];
        i.includes(t) && this.engine.gtmPushTimeData(t), a.includes(t) && this.engine.gtmPushSegmentData(t)
    }
    initEvents() {
        var t = this;
        this.addEventListenerTo(".wvpl-playing-info", "mouseenter", t => {}), this.addEventListener("ended", t => {
            this.skip()
        }), this.addEventListener("peaksloaded", e => {
            const s = e.detail.peaks.join(",").replace(/0\./gi, ".");
            this.updateOverlay(0, "saving the peak file&hellip;");
            const i = {
                nonce: t.engine.vars.ajax_nonce,
                peaks: s,
                temp_file: t.getTrackData("temp_file"),
                id: t.getTrackData("id"),
                type: t.getTrackData("type") || ""
            };
            t.engine.ajaxCall("write_peaks", i).then(e => {
                t.analyzed(), e.success ? (t.preloadTrack(t.clicked), t.getTrackData("temp_file") && (t.setTrackData("id", e.data.id), t.setTrackData("temp_file", null))) : this.log(e.data.message)
            })
        }), this.addEventListenerTo("canvas", "mouseout", e => {
            t.status === WVPL_STATUS_PLAY && (t.mousePosition = -1)
        }), this.addEventListenerTo("canvas", "mousemove", e => {
            t.status === WVPL_STATUS_PLAY && (t.mousePosition = window.devicePixelRatio * e.offsetX)
        }), this.addEventListenerTo(".wvpl-volume", "mousedown", e => {
            e.preventDefault(), t.startOffset = e.clientX, t.node.querySelector(".wvpl-volume-overlay").innerHTML = Math.round(100 * t.engine.getVolume());
            let s = e.target;
            t.timerVolumeOverlay = setTimeout(function() {
                t.volumeDragging = !0, t.addClassTo(".wvpl-volume-overlay", "dragging"), t.addClassTo(".wvpl-controls", "wvpl-inactive"), t.mouseMoveListener = function(e) {
                    e.preventDefault(), s.classList.add("dragging");
                    var i = Math.round(100 * (t.engine.getVolume() + (e.clientX - t.startOffset) / (t.getFirst(".wvpl-interface").offsetWidth * window.devicePixelRatio / 2))) / 100;
                    i >= 0 && i <= 1 && (t.engine.setVolume(i), t.getFirst(".wvpl-volume-overlay").innerHTML = Math.round(100 * i), s.classList.toggle("wvpl-volume_off", 0 == i))
                }, t.mouseUpListener = function(s) {
                    e.preventDefault(), document.removeEventListener("mousemove", t.mouseMoveListener), document.removeEventListener("mouseup", t.mouseUpListener), t.node.querySelector(".dragging").classList.remove("dragging"), t.node.querySelector(".wvpl-controls").classList.remove("wvpl-inactive"), t.volumeDragging = !1
                }, document.addEventListener("mousemove", t.mouseMoveListener), document.addEventListener("mouseup", t.mouseUpListener)
            }, 150)
        }), this.addEventListenerTo(".wvpl-volume", "mouseup", e => {
            clearTimeout(t.timerVolumeOverlay), t.volumeDragging || (this.engine.toggleMute(), e.currentTarget.classList.toggle("wvpl-volume_off", this.engine.isMuted()))
        })
    }
    log(...t) {
        this.engine.isDebugMode() && console.debug(...t)
    }
}
document.addEventListener("waveplayer.engine.ready", t => {
    window.WavePlayer = t.detail.engine
}), document.addEventListener("readystatechange", function(t) {
    const e = window.wvplVars && window.wvplVars.is_gutenberg ? "interactive" : "complete";
    if (document.readyState !== e) return !1;
    microStart = window.performance.now();
    const s = jQuery;
    let i = window;
    for (; !i.wp;) i = i.parent;
    if (void 0 === i.wvplVars) return !1;
    new WVPLEngine(i);
    s.fn.waveplayer = function(t, ...e) {
        return this.each(function(i, a) {
            t = t || "init";
            var n = s(a),
                r = null,
                o = n.attr("data-instance_id");
            if (r = WavePlayer.getInstanceById(o)) return "object" != typeof e && (e = [e]), void r[t].apply(r, e)
        })
    }, document.addEventListener("click", t => {
        if (!document.querySelector(".waveplayer")) return !1;
        WavePlayer.resume();
        let e = t.target;
        const s = t.target.closest("li.wvpl-product-variation");
        if (s) {
            const t = s.closest("#wvpl-variation-popup").dataset.instance,
                e = WavePlayer.getInstanceById(t);
            return void e.addVariationToCart(s.dataset.variation, s.dataset.product)
        }
        const i = e.closest(".waveplayer") || WavePlayer.node;
        if (!i) return;
        const a = WavePlayer.getInstanceById(i.dataset.instance_id);
        if (e.matches(".wvpl-share-popup li")) {
            const t = e.closest(".wvpl-share"),
                s = "share",
                i = e.dataset.social;
            a.trigger(s), a.socialShare.apply(a, [t, i])
        }
        if (e.matches(".wvpl-button")) {
            !e.matches(".wvpl-downloads") && e.querySelector("a.wvpl-link") && e.click();
            const t = e.dataset.event;
            t && a.trigger(t);
            const s = e.dataset.callback;
            if (!s) return;
            a[s].apply(a, [e])
        } else if (!e.matches(".wvpl-link") || !e.attributes.download) {
            if (e.matches(".wvpl-info")) return t.preventDefault(), void a.toggleInfoState();
            if (e.matches(".wvpl-play")) return t.preventDefault(), void a.toggle();
            if (e.matches(".wvpl-prev:not(.wvpl-disabled), .wvpl-next:not(.wvpl-disabled)")) {
                t.preventDefault();
                const s = e.classList.contains("wvpl-next");
                a.skip(s)
            } else {
                if (e.matches("canvas")) return t.preventDefault(), void(a.status == WVPL_STATUS_PLAY ? (a.runtime += (new Date).getTime() - a.lastStart, a.lastStart = (new Date).getTime(), a.trigger("jump"), WavePlayer.setCurrentTime(WavePlayer.getDuration() * t.offsetX / e.offsetWidth)) : a.play());
                if (e.matches(".wvpl-playlist li") || e.matches(".wvpl-playlist li>*:not(.wvpl-icon)")) {
                    "LI" !== e.tagName && (e = e.closest("li")), t.preventDefault(), WavePlayer.isPaused() && WavePlayer.resume();
                    let s = 0,
                        i = e;
                    for (s = 0; i = i.previousSibling; s++);
                    a.skipTo(s)
                } else if (e.matches("button.wvpl-sticky-player-toggle")) WavePlayer.toggleStickyPlayer();
                else {
                    if (e.matches("#wvpl-sticky-player canvas")) return t.preventDefault(), WavePlayer.resume(), void a.maybeSwitch().then(() => {
                        a.play()
                    }).catch(() => {
                        if (a.status == WVPL_STATUS_PLAY) {
                            const e = t.currentTarget;
                            a.runtime += (new Date).getTime() - a.lastStart, a.lastStart = (new Date).getTime(), WavePlayer.setCurrentTime(WavePlayer.getDuration() * t.offsetX / e.offsetWidth)
                        } else a.play()
                    });
                    if (e.matches("#wvpl-sticky-player .wvpl-play")) a.toggle();
                    else if (e.matches(".remove_from_cart_button")) {
                        const t = e.dataset.product_id,
                            s = document.querySelectorAll('.wvpl-cart[data-product_id="' + t + '"]');
                        for (const t of s) t.classList.add("wvpl-spin")
                    } else if (e.matches("#wvpl-variation-popup .woocommerce-variation-add-to-cart button")) {
                        t.preventDefault();
                        const s = e.closest(".woocommerce-variation-add-to-cart"),
                            i = s.querySelector('input[name="product_id"]').value,
                            n = s.querySelector("input.variation_id").value;
                        n > 0 && a.addVariationToCart(n, i)
                    } else e.matches("#wvpl-variation-popup") && document.body.classList.remove("wvpl-variation-popup")
                }
            }
        }
    }), document.addEventListener("click", t => {
        const e = t.target;
        if (e.matches("[data-marker]")) {
            t.preventDefault();
            const e = WavePlayer.timeToSeconds(t.target.dataset.marker);
            e && WavePlayer.play(e)
        } else;
    }), window.addEventListener("resize", t => {
        window.frameElement || setTimeout(function() {
            WavePlayer.redrawAllInstances()
        }, 50)
    }), window.addEventListener("beforeunload", t => {
        let e = WavePlayer.getCurrentInstance();
        e && e.updateStatistics()
    });
    let a = !1;
    document.addEventListener("mousedown", t => {
        t.target.matches(".wvpl-volume-slider .touchable") && (a = !0, WavePlayer.setVolume(t.offsetX / t.target.offsetWidth))
    }), document.addEventListener("mousemove", t => {
        t.target.matches(".wvpl-volume-slider .touchable") && a && "touchable" === t.target.className && WavePlayer.setVolume(t.offsetX / t.target.offsetWidth)
    }), document.addEventListener("mouseup", t => {
        a = !1
    });
    let n = "";
    document.addEventListener("timeupdate", t => {
        if (t.target.matches(".waveplayer")) {
            const e = document.querySelectorAll("[data-marker]"),
                s = WavePlayer.secondsToTime(t.detail.time);
            if (e.length && s !== n) {
                let t = e[0];
                for (let i = 1; i < e.length && !(WavePlayer.timeToSeconds(e[i].dataset.marker) > WavePlayer.timeToSeconds(s)); i++) t = e[i];
                for (let t of e) t.classList.remove("current-time-marker");
                if (t.classList.add("current-time-marker"), WavePlayer.getOption("scroll_to_marker")) {
                    const e = t.dataset.behavior ? t.dataset.behavior : "smooth",
                        s = t.dataset.block ? t.dataset.block : "center";
                    t.scrollIntoView({
                        behavior: e,
                        block: s
                    })
                }
                n = s
            }
        }
    }), s(document.body).on("added_to_cart", (t, e, i, a) => {
        if (!a) return;
        const n = a.data("product_id");
        WavePlayer.updateTrackCartStatus(n, "add"), s(`.wvpl-cart[data-product_id=${n}]`).attr("title", WavePlayer.__("Already in cart: go to cart", "waveplayer")).attr("data-event", "goToCart").attr("data-callback", "goToCart").addClass("wvpl-in_cart").removeClass("wvpl-add_to_cart").removeClass("wvpl-spin")
    }), s(document.body).on("removed_from_cart", (t, e, i, a) => {
        if (!a) return;
        const n = a.data("product_id");
        WavePlayer.updateTrackCartStatus(n, "remove"), s(`.wvpl-cart[data-product_id=${n}]`).attr("title", WavePlayer.__("Add to cart", "waveplayer")).attr("data-event", "addToCart").attr("data-callback", "addToCart").addClass("wvpl-add_to_cart").removeClass("wvpl-in_cart").removeClass("wvpl-spin")
    })
});